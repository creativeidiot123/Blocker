# Dynamic Anki Card Allowance System ‚Äî Revised Plan (v3)

---

## Core Logic (unchanged)

```
on each Anki poll:
    if newDue < lastObservedDue:
        cardsDoneToday += (lastObservedDue - newDue)   // user completed cards
    // if newDue > lastObservedDue ‚Üí Anki added new cards, don't touch cardsDoneToday
    lastObservedDue = newDue

effectiveDue    = max(0, currentDue - 20)
allowanceMin    = cardsDoneToday          // 1 card = 1 min
remainingMin    = allowanceMin - usedMin
shouldBlock     = (effectiveDue > 0) && (remainingMin <= 0)
```

Timer ticks **only** while a blocked app is foreground **AND** screen is on. Reset at **4 AM**.

---

## Corrected Scenario Table

| # | Event | Due | lastObs | Done | EffDue | Earned | Used | Remain | Blocked? |
|---|---|---|---|---|---|---|---|---|---|
| 1 | Start, due=20 | 20 | 20 | 0 | 0 | 0 | 0 | 0 | **NO** (eff=0) |
| 2 | Anki adds‚Üí21 | 21 | 21 | 0 | 1 | 0 | 0 | 0 | **YES** |
| 3 | Do‚Üí15 | 15 | 15 | 6 | 0 | **6** | 0 | **6** | **NO** (eff=0) |
| 4 | Do‚Üí0 | 0 | 0 | 21 | 0 | 21 | 0 | 21 | **NO** (21 min banked) |
| 5 | Anki adds‚Üí16 | 16 | 16 | **21** | 0 | 21 | 0 | 21 | **NO** (work preserved!) |
| 6 | Anki adds‚Üí60 | 60 | 60 | **21** | 40 | 21 | 0 | 21 | Has 21 min |
| 7 | Do on PC‚Üí40 | 40 | 40 | **41** | 20 | 41 | 0 | 41 | Has 41 min |
| 8 | Reddit 5min | 40 | 40 | 41 | 20 | 41 | 5 | 36 | toast "36 min" |
| 9 | 2hrs, Insta 10min | 40 | 40 | 41 | 20 | 41 | 15 | 26 | toast "26 min" |
| 10 | AnkiDroid‚Üí25 | 25 | 25 | **56** | 5 | 56 | 15 | 41 | Has allow |
| 11 | Do‚Üí10 | 10 | 10 | **71** | 0 | 71 | 15 | 56 | **NO** (eff=0) |
| 12 | Do‚Üí0 | 0 | 0 | **81** | 0 | 81 | 15 | 66 | **NO** (66 min banked) |

> [!NOTE]
> **v3 fix (issue #4):** Row 3 `Earned` column is now correctly `6`, not `0`.
> **v3 fix (issue #5):** Column renamed from `Allow` ‚Üí `Earned` for clarity: it represents `cardsDoneToday`, not remaining allowance.

---

## File 1 ‚Äî [NEW] [AllowanceManager.kt](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/managers/AllowanceManager.kt)

> [!IMPORTANT]
> **v3 fix (issue #1):** Now a **singleton** via `companion object.getInstance(context)`.
> All consumers (service, activity, worker) share the same in-memory state.

> [!IMPORTANT]
> **v3 fix (issue #2):** Dropped `@Synchronized` from `updateDueCards()`. All fields use atomics with independent reads ‚Äî no compound atomicity needed since each field is meaningful on its own and any momentary inconsistency resolves within 1 tick.

> [!IMPORTANT]
> **v3 fix (issue #12):** `currentDue` is now persisted and restored on restart, closing the 2-second unblock window.

```kotlin
package com.ankit.blocker.managers

import android.content.Context
import android.content.SharedPreferences
import android.os.Handler
import android.os.Looper
import com.ankit.blocker.utils.Logger
import com.ankit.blocker.utils.ToastManager
import android.widget.Toast
import java.util.Calendar
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicLong

/**
 * Core engine for the dynamic Anki card allowance system.
 *
 * SINGLETON ‚Äî use AllowanceManager.getInstance(context).
 *
 * Rules:
 *   - 1 card completed = 1 minute of allowance on blocked apps
 *   - effectiveDue = max(0, rawDue - 20); if effective is 0 ‚Üí apps unlocked
 *   - Usage timer ticks ONLY while a blocked app is foreground AND screen is on
 *   - All counters reset at 4 AM daily
 *
 * Cards-done tracking uses DELTA ACCUMULATION:
 *   - When due DECREASES ‚Üí user did cards ‚Üí add the delta to cardsDoneToday
 *   - When due INCREASES ‚Üí Anki added new cards ‚Üí cardsDoneToday unchanged
 *
 * Thread-safety: All mutable state uses AtomicInteger/AtomicLong (no @Synchronized).
 */
class AllowanceManager private constructor(context: Context) {

    companion object {
        private const val TAG = "AllowanceManager"

        private const val PREF_NAME = "blocker_preferences"
        private const val KEY_LAST_OBSERVED_DUE = "allowance_last_observed_due"
        private const val KEY_CARDS_DONE_TODAY = "allowance_cards_done_today"
        private const val KEY_USED_MS = "allowance_used_ms"
        private const val KEY_LAST_RESET_DATE = "allowance_last_reset_date"
        private const val KEY_LAST_MILESTONE = "allowance_last_milestone"
        private const val KEY_CURRENT_DUE = "allowance_current_due"  // FIX #12

        // Due cards below this threshold are treated as 0 ‚Üí apps unlocked
        private const val DUE_THRESHOLD = 20

        // Milestone thresholds for celebratory toasts
        private val MILESTONES = intArrayOf(10, 30, 50)

        // FIX #13: Maximum cards credited in a single poll cycle
        // Guards against phantom allowance from IPC glitches, sync conflicts, or Anki data resets
        private const val MAX_SINGLE_DELTA = 20

        // Toast cooldown: don't show "allowance active" toast more than once per 30s
        private const val ALLOWANCE_TOAST_COOLDOWN_MS = 30_000L

        // Persist to disk at most once per 30 seconds (usage ticks are every 1s)
        private const val PERSIST_THROTTLE_MS = 30_000L

        // FIX #1: Singleton instance
        @Volatile
        private var INSTANCE: AllowanceManager? = null

        fun getInstance(context: Context): AllowanceManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: AllowanceManager(context.applicationContext).also {
                    INSTANCE = it
                }
            }
        }
    }

    // --- In-memory atomic state ---
    private val lastObservedDue = AtomicInteger(-1) // -1 = not yet initialized
    private val cardsDoneToday = AtomicInteger(0)
    private val currentDue = AtomicInteger(0)
    private val usedMs = AtomicLong(0L)
    private val lastMilestone = AtomicInteger(0)

    // Rate-limit tracking
    private val lastAllowanceToastTime = AtomicLong(0L)
    private val lastPersistTime = AtomicLong(0L)

    // Main-thread handler for toasts (FIX #11)
    private val mainHandler = Handler(Looper.getMainLooper())

    private val prefs: SharedPreferences by lazy {
        context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)
    }

    init {
        restoreState()
    }

    // ==================== PUBLIC API ====================

    /**
     * Called every time we poll Anki for due cards (~every 2 seconds).
     *
     * FIX #2: No @Synchronized ‚Äî all fields are independent atomics.
     */
    fun updateDueCards(rawDue: Int) {
        checkAndResetIfNewDay()

        currentDue.set(rawDue)

        val lastObs = lastObservedDue.get()
        if (lastObs == -1) {
            lastObservedDue.set(rawDue)
            persistStateImmediate()
            Logger.d(TAG, "First due observation: $rawDue")
            return
        }

        if (rawDue < lastObs) {
            // FIX #13: Cap single-poll credit to guard against IPC glitches / sync conflicts
            val rawDelta = lastObs - rawDue
            val completed = rawDelta.coerceAtMost(MAX_SINGLE_DELTA)
            if (rawDelta > MAX_SINGLE_DELTA) {
                Logger.w(TAG, "Suspicious large delta ($rawDelta) capped to $MAX_SINGLE_DELTA")
            }

            // FIX #14: Set lastObservedDue BEFORE crediting cards.
            // If the coalescing job is cancelled between these two operations,
            // this ordering ensures we never double-count completed cards.
            lastObservedDue.set(rawDue)

            val newDone = cardsDoneToday.addAndGet(completed)
            Logger.d(TAG, "Cards completed: +$completed (total today: $newDone)")
            checkMilestones(newDone)
        } else if (rawDue > lastObs) {
            lastObservedDue.set(rawDue)
            Logger.d(TAG, "New cards added by Anki: ${rawDue - lastObs} (done stays: ${cardsDoneToday.get()})")
        } else {
            // rawDue == lastObs ‚Äî no change, skip persistence
            return
        }

        persistStateImmediate()

        Logger.d(TAG, "updateDueCards: raw=$rawDue, done=${cardsDoneToday.get()}, " +
                "effectiveDue=${getEffectiveDue()}, remaining=${getRemainingAllowanceMinutes()}min")
    }

    /**
     * The single blocking decision function.
     */
    fun shouldBlockApp(): Boolean {
        val effDue = getEffectiveDue()
        if (effDue <= 0) return false
        return getRemainingAllowanceMs() <= 0
    }

    /**
     * Called by the usage ticker. Adds exactly [ms] milliseconds to the used time counter.
     * Only called when screen is on and a blocked app is in the foreground.
     */
    fun addUsageTime(ms: Long) {
        usedMs.addAndGet(ms)
        persistStateThrottled()
    }

    fun getRemainingAllowanceMinutes(): Int {
        return (getRemainingAllowanceMs() / 60_000L).toInt().coerceAtLeast(0)
    }

    fun getCardsDoneToday(): Int = cardsDoneToday.get()

    fun getEffectiveDue(): Int = (currentDue.get() - DUE_THRESHOLD).coerceAtLeast(0)

    /**
     * Shows the "allowance active ‚Äî X min remaining" toast.
     * Rate-limited to once per 30 seconds.
     * FIX #11: Dispatches to main thread.
     */
    fun showAllowanceToast() {
        val effDue = getEffectiveDue()
        if (effDue <= 0) return

        val now = System.currentTimeMillis()
        val lastToast = lastAllowanceToastTime.get()
        if (now - lastToast < ALLOWANCE_TOAST_COOLDOWN_MS) return
        if (!lastAllowanceToastTime.compareAndSet(lastToast, now)) return

        val remaining = getRemainingAllowanceMinutes()
        if (remaining > 0) {
            mainHandler.post {
                ToastManager.showImmediate(appContext,
                    "‚è± Allowance active ‚Äî $remaining min remaining", Toast.LENGTH_LONG)
            }
        }
    }

    /**
     * Shows "allowance exhausted" toast. FIX #11: main-thread dispatch.
     */
    fun showExhaustedToast() {
        mainHandler.post {
            ToastManager.showImmediate(
                appContext,
                "‚è∞ Allowance used up! Do more cards to earn time.",
                Toast.LENGTH_LONG
            )
        }
    }

    /**
     * Resets all daily counters. Called by AllowanceResetWorker at 4 AM
     * and by checkAndResetIfNewDay() on the first poll after the 4 AM boundary.
     */
    fun resetDaily() {
        lastObservedDue.set(-1)
        cardsDoneToday.set(0)
        currentDue.set(0)
        usedMs.set(0L)
        lastMilestone.set(0)

        val today = getAllowanceDateString()
        prefs.edit()
            .putInt(KEY_LAST_OBSERVED_DUE, -1)
            .putInt(KEY_CARDS_DONE_TODAY, 0)
            .putInt(KEY_CURRENT_DUE, 0)
            .putLong(KEY_USED_MS, 0L)
            .putString(KEY_LAST_RESET_DATE, today)
            .putInt(KEY_LAST_MILESTONE, 0)
            .apply()

        Logger.d(TAG, "Daily reset complete for $today")
    }

    // ==================== INTERNAL ====================

    // Keep a reference to appContext for toast calls from background threads
    private val appContext: Context = context.applicationContext

    private fun getRemainingAllowanceMs(): Long {
        val allowanceMs = cardsDoneToday.get() * 60_000L
        return (allowanceMs - usedMs.get()).coerceAtLeast(0)
    }

    /**
     * Returns the "allowance date" ‚Äî days split at 4 AM, not midnight.
     * FIX #10: Zero-padded date format.
     */
    private fun getAllowanceDateString(): String {
        val cal = Calendar.getInstance()
        if (cal.get(Calendar.HOUR_OF_DAY) < 4) {
            cal.add(Calendar.DAY_OF_YEAR, -1)
        }
        return String.format(
            "%04d-%02d-%02d",
            cal.get(Calendar.YEAR),
            cal.get(Calendar.MONTH) + 1,
            cal.get(Calendar.DAY_OF_MONTH)
        )
    }

    private fun checkAndResetIfNewDay() {
        val today = getAllowanceDateString()
        val lastDate = prefs.getString(KEY_LAST_RESET_DATE, null)
        if (lastDate != null && lastDate != today) {
            Logger.d(TAG, "New allowance day ($lastDate ‚Üí $today), resetting")
            resetDaily()
        } else if (lastDate == null) {
            prefs.edit().putString(KEY_LAST_RESET_DATE, today).apply()
        }
    }

    /**
     * FIX #12: Now also restores currentDue.
     */
    private fun restoreState() {
        lastObservedDue.set(prefs.getInt(KEY_LAST_OBSERVED_DUE, -1))
        cardsDoneToday.set(prefs.getInt(KEY_CARDS_DONE_TODAY, 0))
        currentDue.set(prefs.getInt(KEY_CURRENT_DUE, 0))  // FIX #12
        usedMs.set(prefs.getLong(KEY_USED_MS, 0L))
        lastMilestone.set(prefs.getInt(KEY_LAST_MILESTONE, 0))
        checkAndResetIfNewDay()
        Logger.d(TAG, "Restored: lastObs=${lastObservedDue.get()}, done=${cardsDoneToday.get()}, " +
                "due=${currentDue.get()}, used=${usedMs.get()}ms, milestone=${lastMilestone.get()}")
    }

    /**
     * Persists state immediately. Use for important state changes (due count changes).
     */
    private fun persistStateImmediate() {
        lastPersistTime.set(System.currentTimeMillis())
        prefs.edit()
            .putInt(KEY_LAST_OBSERVED_DUE, lastObservedDue.get())
            .putInt(KEY_CARDS_DONE_TODAY, cardsDoneToday.get())
            .putInt(KEY_CURRENT_DUE, currentDue.get())  // FIX #12
            .putLong(KEY_USED_MS, usedMs.get())
            .putInt(KEY_LAST_MILESTONE, lastMilestone.get())
            .apply()
    }

    /**
     * Persists state with throttling for high-frequency updates (usage ticks).
     * FIX #7: Now writes ALL fields to avoid partial-state races with persistStateImmediate.
     */
    private fun persistStateThrottled() {
        val now = System.currentTimeMillis()
        val last = lastPersistTime.get()
        if (now - last < PERSIST_THROTTLE_MS) return
        if (!lastPersistTime.compareAndSet(last, now)) return
        prefs.edit()
            .putInt(KEY_LAST_OBSERVED_DUE, lastObservedDue.get())
            .putInt(KEY_CARDS_DONE_TODAY, cardsDoneToday.get())
            .putInt(KEY_CURRENT_DUE, currentDue.get())
            .putLong(KEY_USED_MS, usedMs.get())
            .putInt(KEY_LAST_MILESTONE, lastMilestone.get())
            .apply()
    }

    private fun checkMilestones(totalDone: Int) {
        val prev = lastMilestone.get()
        var highest = prev
        for (m in MILESTONES) {
            if (totalDone >= m && prev < m) {
                highest = m
            }
        }
        if (highest > prev) {
            lastMilestone.set(highest)
            fireMilestoneToast(highest)
        }
    }

    /**
     * FIX #11: Toast on main thread.
     */
    private fun fireMilestoneToast(milestone: Int) {
        val message = when (milestone) {
            10 -> "üéâ Amazing! 10 cards done ‚Äî 10 min unlocked!"
            30 -> "üî• On fire! 30 cards done ‚Äî 30 min unlocked!"
            50 -> "‚≠ê Incredible! 50 cards done ‚Äî 50 min unlocked!"
            else -> "‚úÖ $milestone cards done ‚Äî $milestone min unlocked!"
        }
        mainHandler.post {
            ToastManager.showImmediate(appContext, message, Toast.LENGTH_LONG)
        }
        Logger.d(TAG, "Milestone toast: $message")
    }
}
```

> [!NOTE]
> **v3.1 cleanup:** The broken `prefs.javaClass.classLoader` workaround has been removed. `showAllowanceToast()` now uses `appContext` directly.

---

## File 2 ‚Äî [NEW] [AllowanceResetWorker.kt](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/workers/AllowanceResetWorker.kt)

> [!IMPORTANT]
> **v3 fix (issue #1):** Now calls `AllowanceManager.getInstance(appContext).resetDaily()` ‚Äî same singleton instance as the service.

```kotlin
package com.ankit.blocker.workers

import android.content.Context
import androidx.work.*
import com.ankit.blocker.managers.AllowanceManager
import com.ankit.blocker.utils.Logger
import java.util.Calendar
import java.util.concurrent.TimeUnit

/**
 * Resets daily allowance counters at 4 AM.
 * FIX #1: Uses singleton AllowanceManager ‚Äî resets the SAME instance the service uses.
 */
class AllowanceResetWorker(
    appContext: Context,
    params: WorkerParameters
) : Worker(appContext, params) {

    companion object {
        private const val TAG = "AllowanceResetWorker"
        const val UNIQUE_WORK_NAME = "allowance_daily_reset"

        fun schedule(context: Context) {
            val delayMs = msUntilNext4AM()
            Logger.d(TAG, "Scheduling reset in ${delayMs / 60_000}min")

            val request = OneTimeWorkRequestBuilder<AllowanceResetWorker>()
                .setInitialDelay(delayMs, TimeUnit.MILLISECONDS)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_WORK_NAME,
                ExistingWorkPolicy.REPLACE,
                request
            )
        }

        private fun msUntilNext4AM(): Long {
            val now = Calendar.getInstance()
            val target = Calendar.getInstance().apply {
                set(Calendar.HOUR_OF_DAY, 4)
                set(Calendar.MINUTE, 0)
                set(Calendar.SECOND, 0)
                set(Calendar.MILLISECOND, 0)
            }
            if (!target.after(now)) {
                target.add(Calendar.DAY_OF_YEAR, 1)
            }
            return target.timeInMillis - now.timeInMillis
        }
    }

    override fun doWork(): Result {
        Logger.d(TAG, "4 AM reset triggered")
        try {
            // FIX #1: Singleton ‚Äî resets same in-memory state as service
            AllowanceManager.getInstance(applicationContext).resetDaily()
        } catch (e: Exception) {
            Logger.e(TAG, "Reset failed", e)
        }
        // Re-schedule for next 4 AM
        // NOTE (FIX #15): If the OS kills this worker before reaching this line,
        // AllowanceManager.checkAndResetIfNewDay() serves as a fallback on the next poll.
        // Consider switching to PeriodicWorkRequest for additional robustness.
        schedule(applicationContext)
        return Result.success()
    }
}
```

---

## File 3 ‚Äî [MODIFY] [AnkiBlockManager.kt](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/managers/AnkiBlockManager.kt)

Replace [areCardsDue() ‚Üí Boolean](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/managers/AnkiBlockManager.kt#23-38) with `getDueCardCount() ‚Üí Int` (unchanged from v2):

```diff
-    suspend fun areCardsDue(): Boolean {
-        refreshDueCardsCacheIfNeeded()
-        val count = cachedDueCards.get()
-        if (count > 0) {
-            Logger.d(TAG, "Blocking logic: $count Anki cards are due (from cache)")
-            return true
-        }
-        return false
-    }
+    suspend fun getDueCardCount(): Int {
+        refreshDueCardsCacheIfNeeded()
+        return cachedDueCards.get()
+    }
```

```diff
-     * Forces the cache to expire so the next [areCardsDue] call performs a fresh IPC query.
+     * Forces the cache to expire so the next [getDueCardCount] call performs a fresh IPC query.
```

---

## File 4 ‚Äî [MODIFY] [ToastManager.kt](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/utils/ToastManager.kt)

> [!IMPORTANT]
> **v3 fix (issue #11):** `showImmediate()` posts to the main thread via `Handler(Looper.getMainLooper())` so it's safe to call from any thread (ticker coroutine, worker, etc.).

```diff
+ import android.os.Handler
+ import android.os.Looper

  object ToastManager {
      private var lastToast: WeakReference<Toast>? = null
      private var lastToastTime = 0L
      private val MIN_TOAST_INTERVAL_MS = 1500L
+     private val mainHandler = Handler(Looper.getMainLooper())

      fun show(context: Context, message: String, duration: Int = Toast.LENGTH_SHORT) {
          ...
      }

+    /**
+     * Shows an important toast immediately, bypassing rate limiting.
+     * Thread-safe: always dispatches to main thread.
+     * FIX #11: Safe to call from any thread.
+     */
+    fun showImmediate(context: Context, message: String, duration: Int = Toast.LENGTH_LONG) {
+        mainHandler.post {
+            lastToast?.get()?.cancel()
+            val toast = Toast.makeText(context, message, duration)
+            toast.show()
+            lastToast = WeakReference(toast)
+            lastToastTime = System.currentTimeMillis()
+        }
+    }
  }
```

---

## File 5 ‚Äî [MODIFY] [BlockerAccessibilityService.kt](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/services/BlockerAccessibilityService.kt)

### Change 1: New fields (~line 79)

> [!IMPORTANT]
> **v3 fix (issue #1):** Uses `AllowanceManager.getInstance(this)` ‚Äî not `AllowanceManager(this)`.

```diff
     private lateinit var ankiBlockManager: AnkiBlockManager
+
+    // Dynamic allowance system ‚Äî SINGLETON (FIX #1)
+    private lateinit var allowanceManager: AllowanceManager
+
+    // Usage timer: ticks 1s while a blocked app is foreground & screen on
+    private var usageTickerJob: Job? = null
+
+    // FIX #16: AtomicReference for thread-safe access from both main thread
+    // (onAccessibilityEvent transition detection) and background (ticker coroutine)
+    private val currentForegroundBlockedApp = AtomicReference<String?>(null)
```

### Change 2: Init in [onCreate()](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/services/BlockerForegroundService.kt#103-112) (~line 121)

```diff
         ankiBlockManager = AnkiBlockManager(this)
+        allowanceManager = AllowanceManager.getInstance(this)  // FIX #1: singleton

         blockOverlayManager = com.ankit.blocker.ui.overlay.BlockOverlayManager(this, mainScope)
```

### Change 3: Transition detection in [onAccessibilityEvent()](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/services/BlockerAccessibilityService.kt#356-639) ‚Äî BEFORE early return

> [!IMPORTANT]
> **v3 fix (issue #9):** This code is placed at the very start of [onAccessibilityEvent()](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/services/BlockerAccessibilityService.kt#356-639), **before** the `if (!ankiBlockedApps.contains(eventPackageName) ...)` early-return filter at line 368. This ensures that when the user switches from Reddit (blocked) ‚Üí Home (launcher), the ticker is cancelled even though the launcher event would normally be filtered out.

Insert right after `val eventPackageName = event.packageName?.toString() ?: return` (line 358):

```diff
         val eventPackageName = event.packageName?.toString() ?: return

+        // FIX #9: ALLOWANCE ‚Äî Detect when user LEAVES a blocked app
+        // Must be BEFORE the early-return filter so launcher/home events still trigger cleanup
+        // FIX #16: Use AtomicReference.get() for thread-safe reads
+        val currentBlocked = currentForegroundBlockedApp.get()
+        if (currentBlocked != null && eventPackageName != currentBlocked) {
+            usageTickerJob?.cancel()
+            usageTickerJob = null
+            currentForegroundBlockedApp.set(null)
+            Logger.d(TAG, "Left blocked app ($currentBlocked ‚Üí $eventPackageName) ‚Üí usage ticker stopped")
+        }
+
         // Auto-dismiss logic ...
```

### Change 4: Replace Anki blocking logic in [processEventInBackground()](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/services/BlockerAccessibilityService.kt#640-716) (~lines 651-678)

> [!IMPORTANT]
> **v3 fix (issue #3):** Ticker now **breaks** when `effectiveDue` drops to 0 (instead of `continue`), so a fresh ticker + toast is shown on next re-entry.

```diff
             // PRIORITY 1: Anki Blocking
             if (ankiBlockedApps.contains(eventPackageName)) {
-                if (ankiBlockManager.areCardsDue()) {
-                     val overlayAlreadyUp = blockOverlayManager?.isOverlayShowingFast() == true
-                     if (overlayAlreadyUp && eventType == TYPE_VIEW_SCROLLED) {
-                         Logger.d(TAG, "User scrolling behind overlay ‚Äî pressing HOME")
-                         performGlobalAction(GLOBAL_ACTION_HOME)
-                         return
-                     }
-                     val isUserActive = eventType == TYPE_VIEW_SCROLLED || 
-                                        eventType == TYPE_WINDOWS_CHANGED || 
-                                        eventType == TYPE_WINDOW_STATE_CHANGED
-                     performBlockAction("Anki Cards Due! Finish your reviews first.", backPressCount = 2)
-                     if (isUserActive) {
-                         Logger.d(TAG, "Aggressive Anki Block: Performing HOME press")
-                         performGlobalAction(GLOBAL_ACTION_HOME)
-                     }
-                     return
-                }
+                // Feed due count into allowance system
+                val dueCount = ankiBlockManager.getDueCardCount()
+                allowanceManager.updateDueCards(dueCount)
+
+                if (allowanceManager.shouldBlockApp()) {
+                    // === BLOCKED: effectiveDue > 0 AND no allowance remaining ===
+
+                    // Stop usage ticker if it was running (allowance just exhausted)
+                    if (usageTickerJob?.isActive == true) {
+                        usageTickerJob?.cancel()
+                        usageTickerJob = null
+                        currentForegroundBlockedApp.set(null)
+                        allowanceManager.showExhaustedToast()
+                    }
+
+                    val overlayAlreadyUp = blockOverlayManager?.isOverlayShowingFast() == true
+                    if (overlayAlreadyUp && eventType == TYPE_VIEW_SCROLLED) {
+                        performGlobalAction(GLOBAL_ACTION_HOME)
+                        return
+                    }
+
+                    val isUserActive = eventType == TYPE_VIEW_SCROLLED ||
+                                       eventType == TYPE_WINDOWS_CHANGED ||
+                                       eventType == TYPE_WINDOW_STATE_CHANGED
+
+                    performBlockAction("Anki Cards Due! Earn time by doing reviews.", backPressCount = 2)
+
+                    if (isUserActive) {
+                        performGlobalAction(GLOBAL_ACTION_HOME)
+                    }
+                    return
+
+                } else {
+                    // === ALLOWED: effectiveDue=0 OR has remaining allowance ===
+
+                    // FIX #3: If effectiveDue is 0, DON'T start a ticker ‚Äî apps are free
+                    if (allowanceManager.getEffectiveDue() <= 0) {
+                        // Under threshold ‚Äî free usage, no ticker needed
+                        return
+                    }
+
+                    // Start usage ticker if not already running for this app
+                    // FIX #16: AtomicReference for thread-safe check-then-set
+                    if (currentForegroundBlockedApp.get() != eventPackageName) {
+                        usageTickerJob?.cancel()
+                        currentForegroundBlockedApp.set(eventPackageName)
+                        allowanceManager.showAllowanceToast()
+
+                        usageTickerJob = serviceScope.launch {
+                            while (isActive) {
+                                delay(1000L)
+                                if (!powerManager.isInteractive) continue // Screen off ‚Üí don't tick
+
+                                // FIX #3: If effectiveDue dropped to 0 mid-session, STOP ticker
+                                if (allowanceManager.getEffectiveDue() <= 0) {
+                                    Logger.d(TAG, "EffectiveDue=0 during ticker ‚Äî stopping (free)")
+                                    currentForegroundBlockedApp.set(null)
+                                    break  // BREAK not continue ‚Äî exit ticker entirely
+                                }
+
+                                allowanceManager.addUsageTime(1000L)
+
+                                // Check if allowance just ran out
+                                if (allowanceManager.shouldBlockApp()) {
+                                    Logger.d(TAG, "Allowance exhausted during ticker")
+                                    allowanceManager.showExhaustedToast()
+                                    // FIX #17: performBlockAction already dispatches to mainScope
+                                    // internally ‚Äî no need for withContext(Dispatchers.Main)
+                                    performBlockAction("Allowance used up! Do more cards.", backPressCount = 2)
+                                    performGlobalAction(GLOBAL_ACTION_HOME)
+                                    currentForegroundBlockedApp.set(null)
+                                    break
+                                }
+                            }
+                        }
+                    }
+                    return
+                }
             }
```

### Change 5: Cancel ticker on feature disable in [onSharedPreferenceChanged()](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/services/BlockerAccessibilityService.kt#333-355)

> [!IMPORTANT]
> **v3 fix (issue #8):** When Anki blocker is disabled, cancel the ticker immediately.

```diff
     override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences?, key: String?) {
         Logger.d(TAG) { "Preferences changed - key: $key" }
         cacheNeedsUpdate = true
         PreferencesHelper.invalidateBlocklistCaches()

         if (key == "protection_enabled" || key == null) {
             val nowEnabled = PreferencesHelper.isProtectionEnabled(this)
             isProtectionEnabled = nowEnabled
             if (!nowEnabled) {
                 Logger.d(TAG, "Protection disabled ‚Äî cancelling settings watchdog immediately")
                 settingsWatchdogJob?.cancel()
                 settingsWatchdogJob = null
                 lastSettingsPackage = null
             }
         }
+
+        // FIX #8: Cancel ticker when Anki blocker is disabled
+        if (key == "anki_blocker_enabled" || key == null) {
+            val ankiEnabled = PreferencesHelper.isAnkiBlockerEnabled(this)
+            if (!ankiEnabled) {
+                Logger.d(TAG, "Anki blocker disabled ‚Äî cancelling usage ticker")
+                usageTickerJob?.cancel()
+                usageTickerJob = null
+                currentForegroundBlockedApp.set(null)
+            }
+        }
     }
```

### Change 6: Cancel ticker in [onDestroy()](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/services/BlockerForegroundService.kt#282-292) (~line 721)

```diff
     override fun onDestroy() {
         try {
+            // FIX: Cancel usage ticker
+            usageTickerJob?.cancel()
+
             // Cancel all coroutines
             serviceScope.cancel()
             mainScope.cancel()
```

---

## File 6 ‚Äî [MODIFY] [BlockerForegroundService.kt](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/services/BlockerForegroundService.kt)

```diff
+import com.ankit.blocker.workers.AllowanceResetWorker

     private fun startForegroundService() {
         try {
             ...
             scheduleHealthCheckWorker()
+            AllowanceResetWorker.schedule(this)
         } catch (e: Exception) {
```

---

## File 7 ‚Äî [MODIFY] [AnkiBlockerActivity.kt](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/ui/AnkiBlockerActivity.kt)

> [!IMPORTANT]
> **v3 fix (issue #1):** Uses `AllowanceManager.getInstance(this)` ‚Äî reads from same singleton.

```diff
+import com.ankit.blocker.managers.AllowanceManager

 class AnkiBlockerActivity : AppCompatActivity() {
     ...
+    private lateinit var allowanceStatusText: TextView
+    private lateinit var cardsDoneTodayText: TextView
+    private lateinit var allowanceManager: AllowanceManager

     override fun onCreate(savedInstanceState: Bundle?) {
         ...
+        allowanceManager = AllowanceManager.getInstance(this)  // FIX #1: singleton
+        cardsDoneTodayText = findViewById(R.id.cardsDoneTodayText)
+        allowanceStatusText = findViewById(R.id.allowanceStatusText)

     private fun updateUI() {
         ...
         // After dueCardsText update, add:
+        val cardsDone = allowanceManager.getCardsDoneToday()
+        val remaining = allowanceManager.getRemainingAllowanceMinutes()
+        cardsDoneTodayText.text = "Cards Done Today: $cardsDone"
+        allowanceStatusText.text = "Allowance: $remaining min remaining (of $cardsDone min earned)"
```

---

## Race Condition Analysis (Revised)

| Scenario | Mitigation |
|---|---|
| Two events fire simultaneously for different blocked apps | `usedMs` is `AtomicLong`; `cardsDoneToday` is `AtomicInteger` ‚Äî independent atomic ops |
| App killed mid-usage | Ticker dies with scope. At most 30s usage lost (throttled persist). **FIX #7**: Throttled persist now writes all fields. |
| `lastObservedDue` updated while ticker reads `shouldBlockApp()` | Atomics ‚Äî momentary inconsistency resolves in 1s. **FIX #2**: No mixed `@Synchronized` anymore. |
| 4 AM worker runs while service is active | **FIX #1**: Singleton ‚Äî worker resets same atomics the service reads. Immediate effect. |
| Toast spam on rapid app switching | `showAllowanceToast()` rate-limited to 30s via CAS. |
| Due flickers (ContentProvider hiccup) | **FIX #13**: Delta capped to `MAX_SINGLE_DELTA=20` per poll. Bounce 40‚Üí38‚Üí40 credits 2 (under cap). Sync-conflict 50‚Üí0 capped to 20, not 50. |
| User switches blocked‚Üíhome‚Üíchrome | **FIX #9**: Transition detection fires on launcher event (before early-return). Ticker cancelled. |
| EffectiveDue drops to 0 mid-ticker | **FIX #3**: Ticker **breaks** (not `continue`). Clean re-entry on next visit. |
| Anki blocker disabled while ticker running | **FIX #8**: [onSharedPreferenceChanged](file:///c:/Users/ankit/AndroidStudioProjects/Blocker/app/src/main/java/com/ankit/blocker/services/BlockerAccessibilityService.kt#333-355) cancels ticker and clears state. |
| SharedPrefs `.apply()` from throttled vs immediate | **FIX #7**: Both paths write all keys ‚Üí last writer wins with full state. |
| Coalescing job cancelled between `lastObservedDue.set()` and `addAndGet()` | **FIX #14**: `lastObservedDue` is set BEFORE `cardsDoneToday.addAndGet()` ‚Äî if cancelled after set but before add, the delta is simply lost (safe). Never double-counted. |
| `currentForegroundBlockedApp` read/written from main thread + ticker | **FIX #16**: Changed to `AtomicReference<String?>` with `.get()` / `.set()` ‚Äî no torn reads. |
| `performBlockAction` double-dispatched via `withContext(Main)` | **FIX #17**: Removed `withContext(Dispatchers.Main)` wrapper ‚Äî `performBlockAction` already dispatches to `mainScope` internally. |
| 4 AM worker killed before self-rescheduling | **FIX #15**: `checkAndResetIfNewDay()` on first poll after 4 AM serves as fallback. |

---

## Verification Plan

1. `./gradlew assembleDebug` ‚Üí install
2. **Due < 20**: 15 due ‚Üí apps **not** blocked
3. **Due ‚â• 20**: 25 due ‚Üí apps **are** blocked
4. **Do 10 cards**: Verify üéâ toast + 10 min allowance
5. **Open blocked app**: Verify ‚è± toast with remaining time
6. **Use 5 min, leave, come back 2hr later**: Timer paused, same remaining
7. **Exhaust allowance**: Verify ‚è∞ toast + blocking resumes
8. **Do cards on PC/AnkiDroid**: Verify allowance increases (delta tracking)
9. **Lock phone while in blocked app**: Verify timer **pauses** (screen-off)
10. **4 AM reset**: Verify counters reset to zero
11. **Switch Reddit ‚Üí Home ‚Üí Chrome**: Verify ticker stops (FIX #9)
12. **Kill app while using blocked app, reopen**: Verify `currentDue` is restored ‚Äî blocking doesn't lapse (FIX #12)
13. **Disable Anki blocker toggle while ticker running**: Verify ticker stops immediately (FIX #8)
14. **Open AnkiBlockerActivity while service is ticking**: Verify UI shows live `cardsDone` / `remaining` from same singleton (FIX #1)
